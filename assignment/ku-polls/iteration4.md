---
title: KU Polls Iteration 4
---

## Goal for Iteration 4

The objective of this iteration is to produce an app that others
can install and run.  After Iteration 3, KU Polls has useful
functionality, even though not everything in the Vision Statement
has been implemented.

Work to do in this iteration includes:

1. Create *data fixtures* for the users and polls data, so an installer can recreate the database and your polls using *any* database
2. Remove the database from git 
3. Run your app in a *virtual environment*. You need to test this carefully.
4. Write instructions for someone to install your app from Github including:
   - install the code from Github
   - create a virtual environment and install dependencies in it
   - run migrations 
   - install data from the data fixtures
   - **anything else** your app needs during installation
5. Test your installation instructions. 
   - Make a fresh clone from Github and follow your instructions, line by line.
6. Add "How to Run" instructions that include using the virtual env. This is separate from Installation (done only once).
7. Code cleanup: use flake8 to find coding issues and unused imports. Fix them.  A few exceptions to flake8 code analysis are allowed:
   - code autogenerated by Django (migrations) can be ignored
   - lines in models can be up to 100 chars long
   - minor issues like missing docstring in `__init__.py` files can be ignored


## Requirements

1. Create an Iteration 4 Plan in your wiki.
2. Add Iteration 4 tasks to your Project and to an "Iteration 4" task board.
   - Also convert tasks to "Issues" so they appear in your repo on Github.
3. Do work on an `iteration4` branch and push it to Github regularly.
4. When finished, open a PR and merge into `main` (of course).

### Creating Data Fixtures

You can import and export data to/from a database in many formats. A Django *data fixture* is a file in JSON format.  To export data, use `manage.py dumpdata`. 

Here are some examples:

1. Dump all data for the `polls` app in JSON format.  Output goes to the console and is hard to read:
   ```
   python manage.py dumpdata polls
   ```
2. Dump data in "pretty print" format, indented 2 spaces per level
   ```
   python manage.py dumpdata --indent=2 polls
   ```
3. Dump data only for the Question and Choice tables (no votes).
   ```
   python manage.py dumpdata --indent=2 polls.question polls.choice
   ```
4. Dump all polls data to a file (`-o`) named polls.json
   ```
   python manage.py dumpdata --indent=2 -o polls.json polls
   ```
5. Dump the auth.user model data to a file `data/users.json` (the directory must already exist)
   ```
   python manage.py dumpdata --indent=2 -o data/users.json auth.user
   ```

If you dump *all* data from the "auth" app (not just `auth.user`), you may have conflicts when you try to import the data into a new database. This is because migrations also create an `auth` app with database tables containing some data.

### Importing data from a file

`manage.py loaddata` reads data from one or more files.  It will fail if the data conflicts with something already in database, or the table schema doesn't match. So its usually used on a "clean" database.  

Here are some examples.

First, get rid of your existing database -- delete it, rename it, or move to a different directory:
```
rm db.sqlite3
# Windows: DEL or DELETE
```

Create a new database by running migrations.
Then import data using "loaddata":
```
python manage.py migrate
python manage.py loaddata polls.json users.json
```

**Where to put the json files?**  You can put them *anywhere*; here are 2 options:

1. Django looks in a `fixtures` directory in each app. If you put the data files in `polls/fixtures/` then load data using:
   ```
   python manage.py loaddata foo bar   # looks for foo.json and bar.json in polls/fixtures
   ```
2. If `polls.json` is in the current directory where manage.py is, use:
   ```
   python manage.py loaddata polls.json
   ```
3. If you put your .json files in a directory named `data` then include the path to the file(s):
   ```
   python manage.py loaddata data/polls.json data/users.json
   ```

**See**:

- My [Data Import and Export](https://cpske.github.io/ISP/django/data-import-export) write-up.
- [Providing Initial Data for Models](https://docs.djangoproject.com/en/2.2/howto/initial-data/) in the official Django docs.
- [Data Migrations](https://realpython.com/data-migrations/) on RealPython.com describes how to create a migration for initial data.

### Virtual Environment

It's a good practice to install app dependencies in a virtual environment,
so that the packages don't modify or corrupt the system's Python installation.

(Demo in lab.)

Here's an example of creating a virtual env and installing dependencies. 
You can use either `python -m venv` or the `virtualenv` tool (separate package).  Virtualenv claims to be faster and better, as explained on
[StackOverflow](https://stackoverflow.com/questions/44091886/whats-the-difference-between-virtualenv-and-m-venv-in-creating-virtual-env).
So, if you already have `virtualenv` on your system, use it.

```
python -m venv env           # create the virtual env in "env/", only 1 time
. env/bin/activate           # start the virtual env in bash or zsh
pip install -r requirements.txt
```

Do **not** commit the virtual environment (`env` or wherever) to Git. Add the directory name to .gitignore.

To exit the virtualenv, type `deactivate`, or close the terminal window.

**Note:** `env/` has *no relation* to the `.env` file used by python-decouple.

**See**:

- [Virtualenv](https://virtualenv.pypa.io/en/latest/user_guide.html) User Guide.
- My write-up [Using a Virtual Environment](https://cpske.github.io/ISP/django/virtualenv) or [Virtualenv Quickstart](https://cpske.github.io/ISP/django/virtualenv-quickstart).

