## Create a new project

`django-admin startproject myproject`

## Run the empty project
```
cd myproject
python manage.py runserver [port_number|8000]
```

## Create an "app" inside the "myproject" project
This creates a subdir with the name of the app,
and puts some skeleton files in the directory.
```
python manage.py startapp polls  # create directory polls with skel files
```
In the `polls` directory, some important files are:
* `apps.py` - describes the app, in particular the name of Model classes.
* `models.py` - file to put your model classes in
* `urls.py` - request URL mapping file. Include this into the main `urls.py` file.
* `views.py` - define views

## Configure database in `settings.py` 

For Mysql/MariaDB, use:
```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'mydatabase',
        'USER': 'myadminuser',
        'PASSWORD': 'fatchance',
        'PORT': '3306',
        'OPTIONS': {
          'autocommit': True,
        },
    },
```

## Create a Persistent (Model) class

1. Put it in a package folder inside the Django project folder.

2. Classes must extend `models.Model`.

3. The persisted fields are classes in the django.db.models module:
    models.CharField
    models.IntegerField
    models.DateTimeField
    models.ForeignKey(foreign_key_class_name, [options])

4. Add the model class to `myapp/settings.py`.  The Django "migrate" command looks at the INSTALLED_APPS variable (List) for what to examine.
INSTALLED_APPS in defined in `myapp/settings.py` (an autogenerated file).
```
INSTALLED_APPS = {
    'myapp.apps.PollsConfig',
    ...
```

# Create a migration for the models

``` 
> python manage.py makemigrations polls
```
The output should print a migration number (like 0001) and description of what the migration does.
Then create the migration:
```
> python manage.py sqlmigrate polls 0001
```
And perform the migration on the database:
```
> python manage.py migrate polls
   Applying polls.0001 initial... OK
```

# Admin User

A user who can perform maintenance tasks on application.

```shell
> python manage.py createsuperuser
```



# Returning a view

A request URL matching a pattern is passed to a method, along with a django.http.HttpRequest object and any named match values.  Django uses named args after the first one (the HttpRequest).

The method (a controller method) should return a django.http.HttpResponse object or django.http.HttpResponseRedirect (commonly used after completing a POST request).  Typical uses of HttpResponse are:

```python
HttpResponse("A plain string")
HttpResponse( template.render( context_dict, request) )
```

Django uses templates for views.  Templates for an "application" (package) named foo should be in `foo/templates/foo/` (see Django tutorial part 3 for reason).  

For example, to get a listview template for the "movies" app and pass it a list of Movie objects to display (Movie being an entity class), use:

```python
from django.http import HttpResponse
from django.template import loader
from myapp.movies import Movie

def listmovies(request):
    # only first 10 movies
    movie_list = Movie.objects.all()[:10]
    context = {
        'movies': movie_list,
    }
    template = load.get_template('movies/listview.html')
    return HttpResponse( template.render(context, request) )
```

An ugly **shortcut** for this is:
```python
from django.shortcuts import render
from myapp.movies import Movie

def listmovies(request):
    # only first 10 movies
    movie_list = Movie.objects.all()[:10]
    context = { 'movies': movie_list }
    return render(request, 'movies/listview.html', context)
```

## Returning an HTTP error code

`django.http` contains exceptions for common Http errors.

```python
from django.http import Http404
from movies.models import Movie

def getmovie(request, movie_id):
    try:
        movie = Movies.objects.get(pk=movie_id)
    except Movie.DoesNotExist:
        raise Http404("Movie %s not found" % movie_id)
```

## Returning an Http Redirect
After processing a POST, its good practice to redirect the browser
somewhere such as a view page showing results of the post.
To avoid hardcoding URLs, you can refer to scoped urls in your app's
`urls.py` file.  Suppose we have:

```python
# urls.py
from django.conf.urls import url

# This defines namespace. Usually same as app (module) name.
app_name = "movies"

# these patterns are all relative to some root.
# typically a module's urls.py is "include"d into the top level urls.py
# which strips off any matched prefixes.
urlpatterns = [
    url(r'^$', views.index, name='index'),
    url(r'^(?P<movie_id>[0-9]+)$', views.getmovie, name='detail')
]
```

Then redirect user to the "detail" view:
```
from django.http import HttpResponseRedirect
from django.urls import reverse
from .models import Movie

def dopost(request, movie_id):
    # process post data from request.POST[keys]

    return HttpResponseRedirect( reverse('movies:detail', args=(movie_id,)))
```
